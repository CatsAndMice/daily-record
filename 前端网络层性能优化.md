# 前端网络层性能优化  
问题：从客户端输入URL地址到看到页面，中间经历了什么？  
1. URL解析  
* 地址解析  
	协议(http,https,FTP),域名，端口号(http默认80,https默认443,FTP默认21)  
	* 编码  
	```javascript
		//例如，发送下面的URL时，带有要传递的参数，为了安全要对传递的参数进行编码
    let http = 'http://www.bai.com/api/?name=李海&age=20'

	//=>对整个URL编码：处理空格与中文
	//encodeURl /decodeURl
	window.encodeURl(http)//"http://www.bai.com/api/?name=%E6%9D%8E%E6%B5%B7&age=20"
	
	//=>只对传递的参数信息进行编码  
	encodeURLComponent/decodeURLComonent
	```  

2. 缓存检查   
  先检查是否存在强缓存
	  * 有，且未失效，走强缓存 
	  * 如果没有，或者失效检查是否有协调缓存 
		  * 有，走协商缓存 
		  * 没有，获取最新数据 
	> 缓存位置
	* Memory cache   内存缓存 
	*  Disk cache        硬盘缓存

打开网页：查找硬盘缓存(Disk cache),如有则使用，如没有则发送网络请求;  

普通刷新(F5): 	因TAB没有关闭，因此内存缓存(Memory cache)可用，会被优先使用，其次使用硬盘缓存(disk cache);    
  
强制刷新(Ctrl+F5): 	浏览器使用缓存，因此发送的请求头部都均带有Cache-control:no-cache,服务器直接返回200和最新内容;   
  

**流程：**如果客户端请求没有强缓存,会直接向服务器发送HTTP请求。服务器会返回请求结果和缓存标识 (Cache-Control      Expires),浏览器识别出缓存标识后会将请求结果和缓存标识存储在浏览器上。
`注意:`http一般不做强缓存 

`问题：`如果服务器文件更新，客户端有强缓存，不就拿不到服务器的更新文件了吗?  
   HTML页面不做强缓存 (每一次的html请求都是正常HTTP请求不走强缓存)  
	   1. 服务器更新资源后，让资源名与之前的不一样
			例如：强缓存的文件名为index.data20.js,服务器更新后的文件名index.data2020.js  
		2. 当文件更新时，在html页面引入外部文件时，设置一个后缀(时间戳)
			例如：之前在html页面引入的js文件`<script src='index.js?12031'></script>` ,服务器文件更新后`<script src='index.js?5203'></script>`改变后面的时间戳  

**协商缓存:(Last-Modified-fied / ETag)**  
>当强缓存失效后，会进行协商缓存，`客户端会带缓存标识向服务器发送HTTP请求`，由服务器根据缓存标识决定是否使用缓存过程。   

客户端带有缓存标识(if-MOdified-Since / If-None-Match)发送HTTP请求,  

服务器根据资源文件是否更新作出反应：
* 资源文件没有更新，返回304，通知客户端读取缓存信息
* 资源文件更新了，返回200及最新的资源信息，以及Last-Modified / ETag

**`强缓存与协商缓存的区别:`**  
协商缓存总是向服务器协商，所以一定会发送HTTP请求

```客户端第一次输入新的URL向服务器发送请求： ```   
 客户端:没有强缓存，也没有协商缓存。  
 向服务器发送没有任何标识的请求;     
 
 服务端：服务器收到请求后准备资源;   
 Last-Modified  资源文件最后更新时间  
 ETag:记录一个标识(根据资源文件更新生成的，每一次资源更新都会重新生成一个ETag) ;   
客户端：拿到服务器传送来的信息后渲染  
把信息和标识缓存在本地
   
**数据缓存:**  (localStorage Vuex或Rudex)
客户端：检测本地缓存的数据信息(是否过期)    
``` javascript
time:xx,//存储时间  
data:[{
...
}]
```
有，且未过期  直接根据本地数据进行渲染   
  
没有，或者过期，基于ajax从服务器获取最新的数据信息

客户端会将最新数据信息缓存到本地    

3. DNS解析  (DNS也是缓存的)  
* 递归查询  
* 迭代查询  
客户端->浏览器缓存->本地的Host文件->本地DNS解析->本地DNS服务器->根DNS  

第一次DNS大约要20ms-120ms  
* 减少DNS请求次数  
> 但是实际项目上不会减少，而是多个服务器

* DNS预获取 
```javascript
<link herf = '//static/360buyimg.com' rel="dns-prefetch" ></link>
<link herf = '//d.jd.com' rel="dns-prefetch" ></link>
<link herf = '//d.cn' rel="dns-prefetch" ></link>
```
> 在发送请求时，link标签会提前请求

*  服务器拆分的优势  
	*  资源的合理利用
	*  挤压能力加强  
	*  提高HTTP开发
	*  ...
> 请求图片一个服务器，请求视频一个服务器  



4. TCP三次握手(建立连接通道)    
> * seq序号，用于标识从TCP源端向目的端发送字节流，发起方发送数据时对此进行标记  
> * ack确认序号，只有ACK标志为1时，确认序号字段才有效， ack = seq+1;  
> * 标志位  
	>  * ACK:确认序号有效
	>  * SYN:发起一个新连接  
	>  *  释放一个连接  

```三次握手为什么不用两次，或者四次？```    
> TCP作为一种可靠传输控制协议，其核心：既要保证数据可靠传输，又要提高传输的效率
二次：客户端发送请求后，不清楚服务器是否接收到了，可能会建立通道失败，  
四次：多余一次，反复问了一次  


5. 数据传输  
HTTP报文
响应状态码  


6. TCP四次挥手
	